import 'examples/Schemes/PRG/CounterPRG.scheme';
import 'examples/Games/PRG/Security.game' as PRGSecurity;
import 'examples/Games/PRF/Security.game' as PRFSecurity;
import 'examples/Primitives/PRF.primitive';

Reduction R(PRF F, PRG G, Int i) compose PRFSecurity(F) against PRGSecurity(G).Adversary {
    Int count;
    Void Initialize() {
        count = 0;
    }
    BitString<G.lambda + G.stretch> Query() {
        count = count + 1;
        if (count < i) {
            BitString<G.lambda + G.stretch> r <- BitString<G.lambda + G.stretch>;
            return r;
        } else if (count == i) {
            BitString<G.lambda> x = challenger.Lookup(0b0);
            BitString<G.lambda> y = challenger.Lookup(0b1);
            return x || y;
        } else {
            BitString<G.lambda> s <- BitString<G.lambda>;
            BitString<G.lambda> x = F.evaluate(s, 0b0);
            BitString<G.lambda> y = F.evaluate(s, 0b1);
            return x || y;
        }
    }
}

proof:

let:
    int lambda;
    int q;
    PRF F = PRF(lambda, lambda, lambda);
    CounterPRG G = CounterPRG(F);

assume:
    PRFSecurity(F);
    calls <= q;

theorem:
    PRGSecurity(G);

games:
    PRGSecurity(G).Real against PRGSecurity(G).Adversary;

    assume R(F, G, 0).count >= 1;

    induction(i from 0 to q) {
        PRFSecurity(F).Real compose R(F, G, i) against PRGSecurity(G).Adversary;
        PRFSecurity(F).Random compose R(F, G, i) against PRGSecurity(G).Adversary;
    }

    PRGSecurity(G).Random against PRGSecurity(G).Adversary;
